<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>CSS: Methodology &amp; Strategy</title>

    <meta name="description" content="CSS: Methodology &amp; Strategy">
    <meta name="author" content="C. Michael Cooper">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">

        <!-- Slide 1 -->
        <section data-markdown>
          # CSS: Methodology &amp; Strategy
          ### Part 1: Goals, Philosophy &amp; Methodology
        </section>

        <!-- Slide 2 -->
        <section data-markdown>
          # What does "Cascading" mean?
          For this presentation, the cascade refers to the mechanism built into CSS that determines which rule should apply, according to the specificity hierarchy, when multiple rules have been defined.
        </section>

        <!-- Slide 3 -->
        <section data-markdown>
          # Goals for our CSS
          * Low specificity
          * High repeatability
          * High context for other developers
          * Intuitive organization / maintainable scope
          * Smallest compiled file size
        </section>

        <!-- Slide 4 -->
        <section data-markdown>
          # Why is CSS difficult?
          ### Global Scope
          * Style rules apply to <em>any</em> element matched by selectors
            * Ex. global h1-h6 styles
          * Can be difficult to force styles to not be applied
              * Congrats, now you have to constantly override your global heading styles
        </section>

        <!-- Slide 5 -->
        <section data-markdown>
          # Why is CSS difficult?
          ### Specificity
          * Treated as a consequence rather than a tool
          * IDE tools do not advise about specificity
          * IDE tools do not track competing selectors
          * Browser dev tools display style overrides, but donâ€™t calculate specificity
        </section>

        <!-- Slide 6 -->
        <section data-markdown>
          # Why is CSS difficult?
          ### Shallow Functional Requirements<br />&amp; No Feedback Mechanism
          * Your code works but it sucks - and CSS don't care
          * There is no native method of error checking
          * SASS compiler will catch some errors, but can't fix bad code
        </section>

        <!-- Slide 7 -->
        <section data-markdown>
          # Why is CSS difficult?
          ### SASS Adds Complexity
          * Nesting can result in gross selectors and specificity overload
          * Variables are easy to misuse
          * Extends are unpredictable
        </section>

        <!-- Slide 8 -->
        <section data-markdown>
          # What can we do about it?
          * Proactively understand and utilize Global Scope &amp; Specificity
          * Use SASS to offset the native weaknesses of CSS
          * Utilize a linter to get code hints in your editor
        </section>

        <!-- Slide 9 -->
        <section data-markdown>
          # Understanding Global Scope
          ### Why is Global Scope bad?
          * Similar objects in different contexts can start specificity wars
          * Difficult to nail down where a style is applied on a large site
          * Difficult or impossible to clean out unused styles
        </section>

        <!-- Slide 10 -->
        <section data-markdown>
          # Understanding Global Scope
          ### Why is Global Scope good?
          * Can add new views and styles work (as long as markup conforms)
          * Reusability/repeatability - describe patterns that can appear anywhere on one or more sites
          * Can maintain a collection of style descriptions in the abstract, without the need for specific application
          * Can create portable patterns that can be migrated to any project
        </section>

        <!-- Slide 11 -->
        <section data-markdown>
          # Understanding Global Scope
          ### Should we resist Global Scope?
          Modern frameworks have started exploring approaches that achieve local scope with CSS, typically by applying styles inline with javascript.
          #### Notable Points
          * On a truly component-based, modular website this might eliminate global scope and specificity concerns
          * Mixing CSS into Javascript bothers many developers
          * Media queries are difficult in this context, and maintaining large/complex sites is difficult
          * Some form of global stylesheet may still be unavoidable
          * Expect to see more of this, particularly because of React's popularity
        </section>

        <!-- Slide 12 -->
        <section data-markdown>
          ## I argue that Global Scope is beneficial because it encourages creating repeatable patterns versus one-off solutions.
        </section>

        <!-- Slide 13 -->
        <section data-markdown>
          # Proactively Managing Specificity
          * Specificity is a _tool_ to be used carefully
          * Atomic or component-based web design is changing how we think specificity should be utilized
            * Older CSS guides on the internet have advocated higher specificity rules to target nested elements
            * Newer approaches advocate un-nested, class-driven, low specificity css modules
          * Naming conventions / name-spacing can be utilized to make managing specificity much easier
        </section>

        <!-- Slide 14 -->
        <section data-markdown>
          # Concerning Preprocessors
          * An inevitable addition to modern development stacks
          * Add features which move CSS closer to programming languages
            * Variables, extends, mixins, functions
            * Mixin libraries can mitigate browser prefixes
          * If not used carefully, preprocessor features can lead to specificity wars and bloated files
        </section>

        <!-- Slide 15 -->
        <section data-markdown>
          # CSS/SASS Methodology
        </section>

        <!-- Slide 16 -->
        <section data-markdown>
          # Specificity Hierarchy
          ```
  // inline styling
  h1 style="color: red;"

  // !important
  h1 {color: red !important;}

  // ID selector
  #foo {}

  // Class selector
  .bar {}

  // Element selector
  h1 {}
          ```
          [Specificity Calculator](http://specificity.keegan.st/)  
          [Example](examples/specificity-example.html)
        </section>

        <!-- Slide 17 -->
        <section data-markdown>
          # Enterprise-level Best Practices
          Avoid using selectors that are tied to specific markup, even if specificity is low. If the markup changes, the styling breaks.
          * Element selectors &amp; Nesting

          ```
  // Element selectors have the lowest specificity, but cause the most headaches.
  // Stop using them if possible
  .accordion {
    section:target {
      h2 {
        a { color: red; }
      }
    }
  }
          ```

          As a project grows and more devs have hands in the code, this will lead to painful maintenance.
        </section>

        <!-- Slide 18 -->
        <section data-markdown>
          # Enterprise-level Best Practices
          Using IDs for selectors is discouraged.
          * No specific benefit over class selectors
          * High specificity, difficult to override when needed
          * Conforming to standards, can only use once per page which fails in atomic design
          * Best used for programming hooks
        </section>

        <!-- Slide 19 -->
        <section data-markdown>
          # Enterprise-level Best Practices
          * Classes make for the best low-specificity selectors
          * Don't be afraid of long class names

          ```
  .accordion-vertical { some: styles; }
  .accordion-horizontal { some: styles; }
  .accordion-section { some: styles; }
  .accordion-title { some: styles; }
  .accordion-link { some: styles; }
          ```
        </section>

        <!-- Slide 20 -->
        <section data-markdown>
          # SASS Best Practices
          ### Variables
        * Good variables describe their purpose rather than their value
        * But value-oriented variables are useful as easily-remembered keywords
        * Passive Variables vs. Active Variables
            * Passive variables store values and pass value to Active variables
            * Active variables describe purpose and are used in rules
            * Think config vs. implementation

          ```
$medium-blue: #336699; // Bad variable - superfluous if design changes
$border-color: #336699; // Good variable - updates if design changes
$brand-blue: #336699; // Good variable - passively stores brand color
$border-color: $brand-blue; // Good variable - actively defines border color
          ```
        </section>

        <!-- Slide 21 -->
        <section data-markdown>
            # SASS Best Practices
            ### Variables
          * Should not re-declare a value that is already defined
          * CSS supports keywords for many values, particularly [colors](http://www.w3schools.com/cssref/css_colornames.asp)
          * Color variables should not be declared just for ease of use
            ```
$color-black: #000; // Ease of use variables
$color-white: #fff; // Ease of use variable

h1 { color: $color-white; } // Still being used as one-offs for memorized values
div { border-color: $color-black; } // Or because a Linter told us to use a variable

h1 { color: white; } // We can just do this for many basic colors

$brand-color: white; // Should we use keyword as passive variable?
$title-color: $brand-color; // The active variable just wants a value
h1 { color: $title-color; } // Yes, because it now indicates purpose
            ```
            [CSS Color Keywords](http://www.w3schools.com/cssref/css_colornames.asp)
        </section>

        <!-- Slide 22 -->
        <section data-markdown>
          # SASS Best Practices
          ### Nesting
        * Great for visualizing mark up hierarchy
        * Locks the developer into styling specifically to markup
          ```
// If this markup hierarchy changes at all, the styling will break entirely
.accordion {
  section:target {
    h2.title {
      a { color:red; padding:0;}
    }
  }
}
          ```
        </section>

        <!-- Slide 23 -->
        <section data-markdown>
          # SASS Best Practices
          ### Nesting
        * Can result in confusing code
          ```
  .tabs {
    overflow: hidden;

    .tab {
      background: red;

      &:hover {
        background: white;
      }

      .tab-link {
        color: white;

        @at-root #{selector-replace(&, '.tab', '.tab:hover')} {
          color: red;
        }
      }
    }
  }
          ```
        </section>

        <!-- Slide 24 -->
        <section data-markdown>
          # SASS Best Practices
          ### Nesting
          * Subtle difference can cause specificity issues

          ```
  // This is repetitive and can scale out of control
  div.content {
    h2 {
      a { color: red; }
    }
  }
  div.sidebar {
    h2 {
      a { color: blue; }
    }
  }

  // This is more efficient and repeatable
  .content-link { color: red; }
  .sidebar-link { color: blue; }
          ```
        </section>

        <!-- Slide 25 -->
        <section data-markdown>
          # SASS Best Practices
          ### Nesting
          * Use classes for objects
          * Use nesting for states and pseudo-classes

          ```
  div.content {
    h2 {
      a { some: styles; }
    }
  }

  // Becomes
  .content { some: styles; }
  .content-title { some: styles; }
  .internal-link { some: styles;
    &:after { some: icon; }
    &:hover { some: hover-styles; }
  }
          ```
        </section>

        <!-- Slide 26 -->
        <section data-markdown>
          # SASS Best Practices
          ### Mixins
          * Best use of global scope and specificity to achieve repeatability
          * Can utilize arguments for dynamic style values
          * Very powerful when used with variables

          ```
// We can create a border style mixin where the border color can be changed once
// And applied to every object on the site that uses this border style
$brand-color: orange;
@mixin border($radius: 4px, $color: $brand-color, $width: 2px, $style: solid) {
  border-radius: $radius;
  border-color: $color;
  border-width: $width;
  border-style: $style;
}

.my-class {
  @include border;
}

// Or we can declare values to create one-off styling instances
.my-alt-class {
  @include border(5px, white, 3px, dotted)
}
          ```
        </section>

        <!-- Slide 27 -->
        <section data-markdown>
          # SASS Best Practices
          ### Extends
          An example of what @extend does

          ```
  .selector-A {
    @extend .selector-B;
    unicorn: true;
  }

  .selector-B {
    rainbow: true;
  }

  // Results in
  .selector-A {
    unicorn: true;
  }

  .selector-B,
  .selector-A {
    rainbow: true;
  }
          ```
        </section>

        <!-- Slide 28 -->
        <section data-markdown>
          # SASS Best Practices
          ### Extends
          * Cannot be used within <code>@media</code> queries
          * Compound extends are unpredictable.
          * Safest to use when you <em>know</em> a selector is only used once in an entire stylesheet

          ```
  %clearfix::after {
  content: '';
  display: table;
  clear: both;
  }
          ```

          * Can result in [ludicrously long selectors](http://pastebin.com/Jy9PqFTy)
        </section>

        <!-- Slide 29 -->
        <section data-markdown>
          # SASS Best Practices
          ### Extends
          * Mixins are more transparent to later developers
          * Mixins do not result in heavier code after Gzip compression
          * Mixins can pass along arguments for more dynamic style applications
          * Mixins allow us to more intentionally control global scope and specificity
        </section>

        <!-- Slide 30 -->
        <section data-markdown>
          # Review
          * Proactively utilize global scope and specificity as tools in your kit
          * Use classes for low-specificity styling rather than element selectors or IDs
          * Avoid nesting to prevent markup-dependent styles
          * Use SASS variables carefully to provide flexibility and maintainability
          * Prefer SASS mixins over extends to keep code transparent and multi-dev friendly
        </section>

        <!-- Slide 31 -->
        <section data-markdown>
          # Next Time...
          * Rebuild the accordion from the bottom up
          * We will learn about specific CSS methods that focus on managing scope, specificity and creating portable modules
            * OOCSS, SMACCS, BEM and Atomic
          * Additional focus on SASS and how to organize and structure a project to maximize maintainability
        </section>

        <!-- Slide 32 -->
        <section data-markdown>
          # Questions?
        </section>

      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });

    </script>

  </body>
</html>
