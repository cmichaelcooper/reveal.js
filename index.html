<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>CSS: Methodology &amp; Strategy</title>

    <meta name="description" content="CSS: Methodology &amp; Strategy">
    <meta name="author" content="C. Michael Cooper">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <h1>CSS: Methodology &amp; Strategy</h1>
        </section>

        <section>
          <h1>And now, My Evil Plan...</h1>
        </section>

        <section>
          <h1>Success depends on two ideas:</h1>
          <ul>
            <li>Maximize CSS Repeatability
              <ul>
                <li>Reusable components. Legos.</li>
              </ul>
            </li>
            <li>Minimize Unplanned Collisions
              <ul>
                <li>Self-contained modules - don't spread dependencies</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h1>CSS is Difficult</h1>
          <h3>We have some challenges to overcome</h3>
        </section>

        <section>
          <h1><strong>Global Scope</strong> &amp; <strong>Specificity</strong></h1>
          <ul>
            <li>Treated as a consequence rather than a tool</li>
            <li>Browsers &amp; IDE tools don't provide insight
              <ul>
                <li>IDE tools do not advise about specificity or competing selectors</li>
                <li>Browser dev tools display style overrides, but don't calculate specificity</li>
              </ul>
            </li>
            <li>Styles must be overwritten (added) to be removed (subtracted)</li>
          </ul>
        </section>

        <section>
          <h1>Shallow Functional Requirements</h1>
          <ul>
            <li>Sloppy, lazy, convoluted or absurd code works - but it sucks</li>
            <li>There is no native method of error checking</li>
            <li>SASS compiler will catch compilation errors, but can't fix sloppy code</li>
          </ul>
        </section>

        <section>
          <h1>SASS Adds Complexity</h1>
          <ul>
            <li>Nesting can result in gross selectors and specificity overload</li>
            <li>Variables are easy to misuse</li>
            <li>Extends are unpredictable</li>
          </ul>
        </section>

        <section>
          <h1>Global Scope in CSS</h1>
        </section>

        <section>
          <h1>The bad:</h1>
          <ul>
            <li>Unrelated styles collide and result in gross overrides</li>
            <li>Developers step on each other's toes as projects age</li>
            <li>Unused styles can interfere with current ones</li>
          </ul>
        </section>

        <section>
          <h1>The good:</h1>
          <ul>
            <li>New views and styles work automatically (as long as markup conforms)</li>
            <li>Reusability/repeatability - describe patterns that can appear anywhere on one or more sites</li>
            <li>Can maintain a collection of style descriptions in the abstract, without the need for specific application</li>
            <li>Can create portable patterns that can be migrated to any project</li>
          </ul>
        </section>

        <section>
          <h1>Is Javascript The Future?</h1>
          <h3>Definitely maybe, but we have concerns</h3>
          <p>What if styling needs to persist but we abandon the framework?</p>
        </section>

        <section>
          <h1>Global Scope Best Practices</h1>
          <ul>
            <li>Normalize and Reset are unnecessary in a component-based system</li>
            <li>Don't declare globally what you know will require overrides</li>
            <li>Never count on a client to adhere to the template</li>
          </ul>
          <pre>
            <code class="hljs" data-trim contenteditable>
// global link rules are a liability
// you're just going to have to override this rule until Ragnarok
a { color: blue; text-decoration: none;

  &:hover { color: green; }
}

// this approach is more versatile and easily extended or overridden
.inline-link { color: blue; text-decoration: none; }
.footer-link { color: green; text-decoration: underline; }

// global header rules are problematic
// unless you're building a blog, these are going to be overridden
h1, h2, h3, h4, h5, h6 { font-family: whatever; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3 { font-size: 20px; }

// this approach is more flexible and also more contextual
.primary-header { font-family: whatever; font-size: 30px; }
            </code>
          </pre>
        </section>

        <section>
          <h1>Specificity</h1>
        </section>

        <section>
          <h1>Specificity Hierarchy</h1>
          <pre>
            <code class="hljs" data-trim contenteditable>
// inline styling
&lt;h1 style="color: red;"&gt;

// !important
h1 {color: red !important;}

// ID selector
#foo {}

// Class selector
.bar {}

// Element selector
h1 {}
            </code>
          </pre>
          <div style="margin-top: 10px;">
            <a href="http://specificity.keegan.st/" target="_blank">Specificity Calculator</a>
          </div>
          <div style="margin-top: 10px;">
            <a href="examples/specificity-example.html" target="_blank">Example</a>
          </div>
        </section>

        <section>
          <h1>Proactively Managing Specificity</h1>
          <ul>
            <li>Specificity is a <strong>tool</strong> to be used carefully</li>
            <li>Atomic or component-based web design is changing how we think specificity should be utilized
              <ul>
                <li>Older CSS guides on the internet have advocated higher specificity rules to target nested elements</li>
                <li>Newer approaches advocate un-nested, class-driven, low specificity css modules</li>
              </ul>
            </li>
            <li>Naming conventions / name-spacing can be utilized to make managing specificity much easier</li>
          </ul>
        </section>

        <section>
          <h1>Specificity Best Practices</h1>
          <p>Avoid using selectors that are tied to specific markup, even if specificity is low. If the markup changes, the styling breaks.</p>
          <ul>
            <li>Element selectors</li>
          </ul>
          <pre>
            <code class="hljs" data-trim contenteditable>
// Element selectors have the lowest specificity, but cause the most headaches.
// Stop using them if possible
.accordion {
  section:target {
    h2 {
      a { color: red; }
    }
  }
}
            </code>
          </pre>
          <p>As a project grows and more devs have hands in the code, this will lead to painful maintenance.</p>
        </section>

        <section>
          <h1>Specificity Best Practices</h1>
          <p>Using IDs for selectors is discouraged.</p>
          <ul>
            <li>No specific benefit over class selectors</li>
            <li>High specificity, difficult to override when needed</li>
            <li>Conforming to standards, can only use once per page which fails in atomic design</li>
            <li>Best used for programming hooks</li>
          </ul>
        </section>

        <section>
          <h1>Specificity Best Practices</h1>
          <ul>
            <li>Classes make for the best low-specificity selectors</li>
            <li>Don't be afraid of long class names</li>
          </ul>
          <pre>
            <code class="hljs" data-trim contenteditable>
.accordion-vertical { some: styles; }
.accordion-horizontal { some: styles; }
.accordion-section { some: styles; }
.accordion-title { some: styles; }
.accordion-link { some: styles; }
            </code>
          </pre>
        </section>

        <section>
          <h1>Preprocessors (SASS)</h1>
        </section>

        <section>
          <h1>Concerning Preprocessors</h1>
          <ul>
            <li>An inevitable addition to modern development stacks</li>
            <li>Add features which move CSS closer to programming languages
              <ul>
                <li>Variables, extends, mixins, functions</li>
                <li>Mixin libraries can mitigate browser prefixes</li>
              </ul>
            </li>
            <li>If not used carefully, preprocessor features can lead to specificity wars and bloated files</li>
          </ul>
        </section>

        <section>
          <section>
            <h1>SASS Best Practices</h1>
            <h3>Variables</h3>
            <p>Variables should allow for significant change with little work</p>
            <ul>
              <li>Good variables describe their purpose rather than their value</li>
              <li>But value-oriented variables are useful as easily-remembered keywords</li>
              <li>Passive Variables vs. Active Variables
                <ul>
                  <li>Passive variables store values and pass value to Active variables</li>
                  <li>Active variables describe purpose and are used in rules</li>
                  <li>Think "config" vs. "implementation"</li>
                </ul>
              </li>
            </ul>
            <pre>
              <code class="hljs" data-trim contenteditable>
$medium-blue: #336699;      // Bad variable - superfluous if design changes
$border-color: #336699;     // Good variable - updates if design changes

$brand-blue: #336699;       // Good variable - passively stores brand color
$border-color: $brand-blue; // Good variable - actively defines border color
              </code>
            </pre>
          </section>
          <section>
          <h1>SASS Best Practices</h1>
          <h3>Variables</h3>
          <ul>
            <li>Should not re-declare a value that is already defined</li>
            <li>CSS supports keywords for many values, particularly <a href="http://www.w3schools.com/cssref/css_colornames.asp" target="_blank">colors</a>
            <li>Color variables should not be declared just for ease of use</li>
          </ul>
          <pre>
            <code class="hljs" data-trim contenteditable>
$color-black: #000; // Ease of use variable
$color-white: #fff; // Ease of use variable

h1 { color: $color-white; } // Still being used as one-offs for memorized values
div { border-color: $color-black; } // Or because a Linter told us to use a variable

h1 { color: white; } // We can just do this for many basic colors

$brand-color: white; // Should we use keyword as passive variable?
$title-color: $brand-color; // The active variable just wants a value
h1 { color: $title-color; } // Yes, because it now indicates purpose
            </code>
          </pre>
          <a href="http://www.w3schools.com/cssref/css_colornames.asp">CSS Color Keywords</a>
          </section>
        </section>

        <section>
          <section>
            <h1>SASS Best Practices</h1>
            <h3>Nesting</h3>
            <ul>
              <li>Great for visualizing mark up hierarchy</li>
              <li>Locks the developer into styling specifically to markup</li>
            </ul>
            <pre>
              <code class="hljs" data-trim contenteditable>
// If this markup hierarchy changes at all, the styling will break entirely
.accordion {
  section:target {
    h2.title {
      a { color:red; padding:0;}
    }
  }
}
              </code>
            </pre>
          </section>
          <section>
            <h1>SASS Best Practices</h1>
            <h3>Nesting</h3>
            <ul>
              <li>Can result in confusing code</li>
            </ul>
            <pre>
              <code class="hljs" data-trim contenteditable>
.tabs {
  overflow: hidden;

  .tab {
    background: red;

    &:hover {
      background: white;
    }

    .tab-link {
      color: white;

      @at-root #{selector-replace(&, '.tab', '.tab:hover')} {
        color: red;
      }
    }
  }
}
              </code>
            </pre>
          </section>
          <section>
            <h1>SASS Best Practices</h1>
            <h3>Nesting</h3>
            <ul>
              <li>Subtle difference can cause specificity issues</li>
            </ul>
            <pre>
              <code class="hljs" data-trim contenteditable>
// This is repetitive and can scale out of control
div.content {
  h2 {
    a { color: red; }
  }
}
div.sidebar {
  h2 {
    a { color: blue; }
  }
}

// This is more efficient and repeatable
.content-link { color: red; }
.sidebar-link { color: blue; }
              </code>
            </pre>
          </section>
          <section>
            <h1>SASS Best Practices</h1>
            <h3>Nesting</h3>
            <ul>
              <li>Use classes for objects</li>
              <li>Use nesting for states and pseudo-classes</li>
            </ul>
            <pre>
              <code class="hljs" data-trim contenteditable>
div.content {
  h2 {
    a { some: styles; }
  }
}

// Becomes
.content { some: styles; }
.content-title { some: styles; }
.internal-link { some: styles;
  &:after { some: icon; }
  &:hover { some: hover-styles; }
}
              </code>
            </pre>
          </section>
        </section>

        <section>
          <section>
            <h1>SASS Best Practices</h1>
            <h3>Mixins</h3>
            <ul>
              <li>Best use of global scope and specificity to achieve repeatability</li>
              <li>Can utilize arguments for dynamic style values</li>
              <li>Very powerful when used with variables</li>
            </ul>
            <pre>
              <code class="hljs" data-trim contenteditable>
// We can create a border style mixin where the border color can be changed once
// And applied to every object on the site that uses this border style
$brand-color: orange;
@mixin border($radius: 4px, $color: $brand-color, $width: 2px, $style: solid) {
  border-radius: $radius;
  border-color: $color;
  border-width: $width;
  border-style: $style;
}

.my-class {
  @include border;
}

// Or we can declare values to create one-off styling instances
.my-alt-class {
  @include border(5px, white, 3px, dotted)
}
              </code>
            </pre>
          </section>
        </section>

        <section>
          <section>
            <h1>SASS Best Practices>
            <h3>Extends</h3>
            <p>An example of what @extend does</p>
            <pre>
              <code class="hljs" data-trim contenteditable>
.selector-A {
  @extend .selector-B;
  unicorn: true;
}

.selector-B {
  rainbow: true;
}

// Results in
.selector-A {
  unicorn: true;
}

.selector-B,
.selector-A {
  rainbow: true;
}
              </code>
            </pre>
          </section>
          <section>
            <h1>SASS Best Practices</h1>
            <h3>Extends</h3>
            <ul>
              <li>Cannot be used within <code>@media</code> queries</li>
              <li>Compound extends are unpredictable.</li>
              <li>Safest to use when you <em>know</em> a selector is only used once in an entire stylesheet</li>
            </ul>
            <pre>
              <code class="hljs" data-trim contenteditable>
%clearfix::after {
  content: '';
  display: table;
  clear: both;
}
              </code>
            </pre>
            <ul>
              <li>Can result in <a href="http://pastebin.com/Jy9PqFTy" target="_blank">ludicrously long selectors</a></li>
            </ul>
          </section>
          <section>
            <h1>SASS Best Practices</h1>
            <h3>Extends</h3>
            <ul>
              <li>Mixins are more transparent to later developers</li>
              <li>Mixins do not result in heavier code after Gzip compression</li>
              <li>Mixins can pass along arguments for more dynamic style applications</li>
              <li>Mixins allow us to more intentionally control global scope and specificity</li>
            </ul>
          </section>
        </section>

        <section>
          <h1>Review</h1>
          <ul>
            <li>Global scope and specificity are powerful tools for crafting portable, modular css</li>
            <li>Use classes for low-specificity styling rather than element selectors or IDs</li>
            <li>Avoid nesting to prevent markup-dependent styles</li>
            <li>Use SASS variables carefully to provide flexibility and maintainability</li>
            <li>Prefer SASS mixins over extends to keep code transparent and multi-dev friendly</li>
          </ul>
        </section>

        <section>
          <h1>Next Time...</h1>
          <ul>
            <li>Rebuild the accordion from the bottom up</li>
            <li>We will learn about specific CSS methods that focus on managing scope, specificity and creating portable modules
              <ul>
                <li>OOCSS, SMACCS, BEM and Atomic</li>
              </ul>
            </li>
            <li>Additional focus on SASS and how to organize and structure a project to maximize maintainability</li>
          </ul>
        </section>

        <section>
          <h1>Questions?</h1>
        </section>

      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });

    </script>

  </body>
</html>
