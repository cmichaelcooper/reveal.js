<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>CSS: Methodology &amp; Strategy</title>

    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Hakim El Hattab">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section>
          <h1>CSS: Methodology &amp; Strategy</h1>
          <h3>Part 1: Goals, Philosophy &amp; Methodology</h3>
        </section>

        <section>
          <h1>What does "Cascading" mean?</h1>
          <p>For this presentation, the cascade refers to the mechanism built into CSS that determines which rule should apply, according to the specificity hierarchy, when multiple rules have been defined.</p>
        </section>

        <section>
          <h1>Goals for our CSS</h1>
          <ul>
            <li>Low specificity</li>
            <li>High repeatability</li>
            <li>High context for other developers</li>
            <li>Intuitive organization / maintainable scope</li>
            <li>Smallest compiled file size</li>
          </ul>
        </section>

        <section>
          <h1>Why is CSS difficult?</h1>
          <h3>Global Scope</h3>
          <ul>
            <li>Style rules apply to <em>any</em> element matched by selectors
              <ul>
                <li>Ex. global <code>&lt;h1&gt;-&lt;h6&gt;</code> styles</li>
              </ul>
            </li>
            <li>Can be difficult to force styles to not be applied
              <ul>
                <li>Congrats, now you have to constantly override your global heading styles</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <h1>Why is CSS difficult?</h1>
          <h3>Specificity</h3>
          <ul>
            <li>Treated as a consequence rather than a tool</li>
            <li>IDE tools do not advise about specificity</li>
            <li>IDE tools do not track competing selectors</li>
            <li>Browser dev tools display style overrides, but donâ€™t calculate specificity</li>
          </ul>
        </section>

        <section>
          <h1>Why is CSS difficult?</h1>
          <h3>Shallow Functional Requirements<br />&amp; No Feedback Mechanism</h3>
          <ul>
            <li>Your code works but it sucks - and CSS don't care</li>
            <li>There is no native method of error checking</li>
            <li>SASS compiler will catch some errors, but can't fix bad code</li>
          </ul>
        </section>

        <section>
          <h1>Why is CSS difficult?</h1>
          <h3>SASS Adds Complexity</h3>
          <ul>
            <li>Nesting can result in gross selectors and specificity overload</li>
            <li>Variables are easy to misuse</li>
            <li>Extends are unpredictable</li>
          </ul>
        </section>

        <section>
          <h1>What can we do about it?</h1>
          <ul>
            <li>Proactively understand and utilize Global Scope &amp; Specificity</li>
            <li>Use SASS to offset the native weaknesses of CSS</li>
            <li>Utilize a linter to get code hints in your editor</li>
          </ul>
        </section>

        <section>
          <h1>Understanding<br />Global Scope</h1>
          <h3>Why is Global Scope bad?</h3>
          <ul>
            <li>Similar objects in different contexts can start specificity wars</li>
            <li>Difficult to nail down where a style is applied on a large site</li>
            <li>Difficult or impossible to clean out unused styles</li>
          </ul>
        </section>

        <section>
          <h1>Understanding<br />Global Scope</h1>
          <h3>Why is Global Scope good?</h3>
          <ul>
            <li>Can add new views and styles work (as long as markup conforms)</li>
            <li>Reusability/repeatability - describe patterns that can appear anywhere on one or more sites</li>
            <li>Can maintain a collections of style descriptions in the abstract, without the need for specific application</li>
            <li>Can create portable patterns that can be migrated to any project</li>
          </ul>
        </section>

        <section>
          <h1>Understanding<br />Global Scope</h1>
          <h3>Should we resist Global Scope?</h3>
          <p>Modern frameworks have started exploring approaches that achieve local scope with CSS, typically by applying styles inline with javascript.</p>
          <h4>Notable Points</h4>
          <ul>
            <li>On a truly component-based, modular website this might eliminate global scope and specificity concerns</li>
            <li>Mixing CSS into Javascript bothers many developers</li>
            <li>Media queries are difficult in this context, and maintaining large/complex sites is difficult</li>
            <li>Some form of global stylesheet may still be unavoidable</li>
            <li>Expect to see more of this, particularly because of React's popularity</li>
          </ul>
        </section>

        <section>
          <h2>I argue that Global Scope is beneficial because it encourages creating repeatable patterns versus one-off solutions.</h2>
        </section>

        <section>
          <h1>Proactively Managing Specificity</h1>
          <ul>
            <li>Specificity is a <strong>tool</strong> to be used carefully</li>
            <li>Atomic or component-based web design is changing how we think specificity should be utilized
              <ul>
                <li>Older CSS guides on the internet have advocated higher specificity rules to target nested elements</li>
                <li>Newer approaches advocate class-driven low specificity css modules</li>
              </ul>
            </li>
            <li>Naming conventions / name-spacing can be utilized to make managing specificity much easier</li>
          </ul>
        </section>

        <section>
          <h1>Concerning Preprocessors</h1>
          <ul>
            <li>An inevitable addition to modern development stacks</li>
            <li>Add features which move CSS closer to programming languages
              <ul>
                <li>Variables, extends, mixins, functions</li>
                <li>Mixin libraries can mitigate browser prefixes</li>
              </ul>
            </li>
            <li>If not used carefully, preprocessor features can lead to specificity wars and bloated files</li>
          </ul>
        </section>

        <section>
          <h1>CSS/SASS Methodology</h1>
        </section>

        <section>
          <h1>Specificity Hierarchy</h1>
          <pre>
            <code class="hljs" data-trim contenteditable>
// inline styling
&lt;h1 style="color: red;"&gt;

// !important
h1 {color: red !important;}

// ID selector
#foo {}

// Class selector
.bar {}

// Element selector
h1 {}
            </code>
          </pre>
          <div style="margin-top: 10px;">
            <a href="http://specificity.keegan.st/" target="_blank">Specificity Calculator</a>
          </div>
          <div style="margin-top: 10px;">
            <a href="examples/specificity-example.html" target="_blank">Example</a>
          </div>
        </section>

        <section>
          <h1>Enterprise-level Best Practices</h1>
          <p>Avoid using selectors that are tied to specific markup, even if specificity is low. If the markup changes, the styling breaks.</p>
          <ul>
            <li>Element selectors &amp; Nesting</li>
          </ul>
          <pre>
            <code class="hljs" data-trim contenteditable>
// Element selectors have the lowest specificity, but cause the most headaches.
// Stop using them if possible
.accordion {
  section:target {
    h2 {
      a { color: red; }
    }
  }
}
            </code>
          </pre>
          <p>As a project grows and more devs have hands in the code, this will lead to painful maintenance.</p>
        </section>

        <section>
          <h1>Enterprise-level Best Practices</h1>
          <p>Using IDs for selectors is discouraged.</p>
          <ul>
            <li>No specific benefit over class selectors</li>
            <li>High specificity, difficult to override when needed</li>
            <li>Conforming to standards, can only use once per page which fails in atomic design</li>
            <li>Best used for programming hooks</li>
          </ul>
        </section>

        <section>
          <h1>Enterprise-level Best Practices</h1>
          <ul>
            <li>Classes make for the best low-specificity selectors</li>
            <li>Don't be afraid of long class names</li>
          </ul>
          <pre>
            <code class="hljs" data-trim contenteditable>
.accordion-vertical { some: styles; }
.accordion-horizontal { some: styles; }
.accordion-section { some: styles; }
.accordion-title { some: styles; }
.accordion-link { some: styles; }
            </code>
          </pre>
        </section>

        <section>
          <section>
            <h1>SASS Best Practices</h1>
            <h3>Variables</h3>
            <ul>
              <li>Good variables describe their purpose rather than their value</li>
              <li>But value-oriented variables are useful as easily-remembered keywords</li>
              <li>Passive Variables vs. Active Variables
                <ul>
                  <li>Passive variables store values and pass value to Active variables</li>
                  <li>Active variables describe purpose and are used in rules</li>
                  <li>Think "config" vs. "implementation"</li>
                </ul>
              </li>
            </ul>
            <pre>
              <code class="hljs" data-trim contenteditable>
$medium-blue: #336699;      // Bad variable - superfluous if design changes
$border-color: #336699;     // Good variable - updates if design changes

$brand-blue: #336699;       // Good variable - passively stores brand color
$border-color: $brand-blue; // Good variable - actively defines border color
              </code>
            </pre>
          </section>
          <section>
          <h1>SASS Best Practices</h1>
          <h3>Variables</h3>
          <ul>
            <li>Should not re-declare a value that is already defined</li>
            <li>CSS supports keywords for many values, particularly <a href="http://www.w3schools.com/cssref/css_colornames.asp" target="_blank">colors</a>
            <li>Color variables should not be declared just for ease of use</li>
          </ul>
          <pre>
            <code class="hljs" data-trim contenteditable>
$color-black: #000; // Ease of use variable
$color-white: #fff; // Ease of use variable

h1 { color: $color-white; } // Still being used as one-offs for memorized values
div { border-color: $color-black; } // Or because a Linter told us to use a variable

h1 { color: white; } // We can just do this for many basic colors

$brand-color: white; // Should we use keyword as passive variable?
$title-color: $brand-color; // The active variable just wants a value
h1 { color: $title-color; } // Yes, because it now indicates purpose
            </code>
          </pre>
          <a href="http://www.w3schools.com/cssref/css_colornames.asp">CSS Color Keywords</a>
          </section>
        </section>

        <section>
          <section>
            <h1>SASS Best Practices</h1>
            <h3>Nesting</h3>
            <ul>
              <li>Great for visualizing mark up hierarchy</li>
              <li>Locks the developer into styling specifically to markup</li>
            </ul>
            <pre>
              <code class="hljs" data-trim contenteditable>
// If this markup hierarchy changes at all, the styling will break entirely
.accordion {
  section:target {
    h2.title {
      a { color:red; padding:0;}
    }
  }
}
              </code>
            </pre>
          </section>
          <section>
            <h1>SASS Best Practices</h1>
            <h3>Nesting</h3>
            <ul>
              <li>Can result in confusing code</li>
            </ul>
            <pre>
              <code class="hljs" data-trim contenteditable>
.tabs {
  overflow: hidden;

  .tab {
    background: red;

    &:hover {
      background: white;
    }

    .tab-link {
      color: white;

      @at-root #{selector-replace(&, '.tab', '.tab:hover')} {
        color: red;
      }
    }
  }
}
              </code>
            </pre>
          </section>
          <section>
            <h1>SASS Best Practices</h1>
            <h3>Nesting</h3>
            <ul>
              <li>Subtle difference can cause specificity issues</li>
            </ul>
            <pre>
              <code class="hljs" data-trim contenteditable>
// This is repetitive and can scale out of control
div.content {
  h2 {
    a { color: red; }
  }
}
div.sidebar {
  h2 {
    a { color: blue; }
  }
}

// This is more efficient and repeatable
.content-link { color: red; }
.sidebar-link { color: blue; }
              </code>
            </pre>
          </section>
          <section>
            <h1>SASS Best Practices</h1>
            <h3>Nesting</h3>
            <ul>
              <li>Use classes for objects</li>
              <li>Use nesting for states and pseudo-classes</li>
            </ul>
            <pre>
              <code class="hljs" data-trim contenteditable>
div.content {
  h2 {
    a { some: styles; }
  }
}

// Becomes
.content { some: styles; }
.content-title { some: styles; }
.internal-link { some: styles;
  &:after { some: icon; }
  &:hover { some: hover-styles; }
}
              </code>
            </pre>
          </section>
        </section>

        <section>
          <section>
            <h1>SASS Best Practices</h1>
            <h3>Mixins</h3>
            <ul>
              <li>Best use of global scope and specificity to achieve repeatability</li>
              <li>Can utilize arguments for dynamic style values</li>
              <li>Very powerful when used with variables</li>
            </ul>
            <pre>
              <code class="hljs" data-trim contenteditable>
// We can create a border style mixin where the border color can be changed once
// And applied to every object on the site that uses this border style
$brand-color: orange;
@mixin border($radius: 4px, $color: $brand-color, $width: 2px, $style: solid) {
  border-radius: $radius;
  border-color: $color;
  border-width: $width;
  border-style: $style;
}

.my-class {
  @include border;
}

// Or we can declare values to create one-off styling instances
.my-alt-class {
  @include border(5px, white, 3px, dotted)
}
              </code>
            </pre>
          </section>
        </section>

        <section>
          <section>
            <h1>SASS Best Practices>
            <h3>Extends</h3>
            <p>An example of what @extend does</p>
            <pre>
              <code class="hljs" data-trim contenteditable>
.selector-A {
  @extend .selector-B;
  unicorn: true;
}

.selector-B {
  rainbow: true;
}

// Results in
.selector-A {
  unicorn: true;
}

.selector-B,
.selector-A {
  rainbow: true;
}
              </code>
            </pre>
          </section>
          <section>
            <h1>SASS Best Practices</h1>
            <h3>Extends</h3>
            <ul>
              <li>Cannot be used within <code>@media</code> queries</li>
              <li>Compound extends are unpredictable.</li>
              <li>Safest to use when you <em>know</em> a selector is only used once in an entire stylesheet</li>
            </ul>
            <pre>
              <code class="hljs" data-trim contenteditable>
%clearfix::after {
  content: '';
  display: table;
  clear: both;
}
              </code>
            </pre>
            <ul>
              <li>Can result in <a href="http://pastebin.com/Jy9PqFTy" target="_blank">ludicrously long selectors</a></li>
            </ul>
          </section>
          <section>
            <h1>SASS Best Practices</h1>
            <h3>Extends</h3>
            <ul>
              <li>Mixins are more transparent to later developers</li>
              <li>Mixins do not result in heavier code after Gzip compression</li>
              <li>Mixins can pass along arguments for more dynamic style applications</li>
              <li>Mixins allow us to more intentionally control global scope and specificity</li>
            </ul>
          </section>
        </section>

        <section>
          <h1>Review</h1>
          <ul>
            <li>Proactively utilize global scope and specificity as tools in your kit</li>
            <li>Use classes for low-specificity styling rather than element selectors or IDs</li>
            <li>Avoid nesting to prevent markup-dependent styles</li>
            <li>Use SASS variables carefully to provide flexibility and maintainability</li>
            <li>Prefer SASS mixins over extends to keep code transparent and multi-dev friendly</li>
          </ul>
        </section>

        <section>
          <h1>Next Time...</h1>
          <ul>
            <li>We will deeper into code and learn about specific CSS methods that focus on managing scope, specificity and creating portable modules
              <ul>
                <li>OOCSS, SMACCS, BEM and Atomic</li>
              </ul>
            </li>
            <li>Additional focus on SASS and how to organize and structure a project to maximize maintainability</li>
          </ul>
        </section>

      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });

    </script>

  </body>
</html>
